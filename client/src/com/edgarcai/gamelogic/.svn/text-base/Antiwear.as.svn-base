package com.edgarcai.gamelogic {	import com.edgarcai.encrypt.IEncrypt;	import com.edgarcai.events.CustomEventDispatcher;	import com.edgarcai.util.Utils;		import flash.events.*;	import flash.net.registerClassAlias;	import flash.utils.ByteArray;	import flash.utils.Proxy;	import flash.utils.flash_proxy;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;
		/**	 * 数据加密储存,防止内存修改。	 * @author edgarcai	 */	dynamic public class Antiwear extends Proxy	{		/**		 * 加密算法		 */		public var encrypt:IEncrypt;		/**		 * 出错时的回调函数		 */		public var errorHandler:Function;				/**		 *  伪值		 */		public var data:Object;		/**		 * 真值		 */		private var _data:Object;				public function Antiwear(encrypt:IEncrypt) 		{			this.encrypt = encrypt;			//trace("encrypt:"+encrypt);			data = new Object();			_data = new Object();			this.errorHandler = defaultErrorHandler;		}				/**		 * 默认错误方法		 * 		 */		protected function defaultErrorHandler():void		{			//throw new Error("数据验证失败！");			//dispatchEvent(new Event("CHECKDATAERROR"));			//ThreeKingdoms._gameWorld._eventManager.dispatchEvent(new GameEvent (GameEvent.CHECK_DATA_ERROR))		}		/**		 * 		 * @param	methodName		 * @param	...args		 * @return		 */		flash_proxy override function callProperty(methodName:*, ...args):*		{			var metrod:* = data[methodName];			return (metrod as Function).apply(null,args);		}				/**		 * 取得对象值		 * @param	property		 * @return		 */		flash_proxy override function getProperty(property:*):* 		{			if (property == null)			{				return null;			}			var v:* = encrypt.decode(_data[property]);			if (v is Number || v is String)			{				if (v != data[property])					errorHandler();			}			else			{				if (!Utils.equal(v,data[property]))					errorHandler();			}						return v;		}				/**		 * 设置对象值		 * @param	property		 * @param	value		 */		flash_proxy override function setProperty(property:*,value:*):void 		{			if (value is Number || value is String)			{				data[property] = value;			}			else			{				data[property] = cloneObject(value);			}			_data[property] = encrypt.encode(value);		}				/**		 * 深度拷贝 		 * @param source		 * @return 		 * 		 */				protected function cloneObject(source:Object) : *		{			var typeName:String = getQualifiedClassName(source);//获取全名  			//return;  			var packageName:String = typeName.split("::")[0];//切出包名  			var type:Class = getDefinitionByName(typeName) as Class;//获取Class  			registerClassAlias(packageName, type);//注册Class  			//复制对象  			var copier:ByteArray = new ByteArray();  			copier.writeObject(source);  			copier.position = 0;  			return copier.readObject();			}	}}